---
title: MySQL之事务隔离级别
categories:
  - MySQL
  - 数据库
tags:
  - MySQL
  - 数据库
date: 2018-10-08 22:14:10
---

事务是数据库一个非常重要的特性，事务并不是MySQL独有，MySQL中也不是所有的存储引擎都支持事务。<!-- more -->而事务的隔离级别对于开发者来讲又非常重要，本篇文章就简单介绍下事务以及事务的隔离级别，另外以使用最广泛的存储引擎InnoDB来介绍它是如何实现事务的隔离级别的。


## 事务

简单来说，事务就是一组SQL语句，这些语句要么全部执行成功，要么全部执行失败。

解释事务必要性一个经典的例子是银行转账，假设张三向李四转账200元，那么至少需要三个步骤：

1. 检查张三账户余额是否大于等于200元
2. 张三账户余额减去200元
3. 李四账户余额增加200元

如果没有事务的话，很有可能发生李三的账户余额已经扣除但李四的余额没有增加这样严重的错误。如果把这三个操作打包成一个事务的话，则要么同时执行成功，要么任意一步失败，前面的操作全部回滚，不会对双方账户余额造成任何影响。

MySQL中的事务默认采用自动提交模式，也就是说，如果不是显示地开启一个事务，则每个查询都被当做一个事务执行提交操作。另外还有一些命令，在执行之前会强制执行```COMMIT```提交当前的活动事务，比如```ALTER TABLE```。

事务具有四个特性，分别是原子性(atomicity)，一致性(consistency)、隔离性(isolation)和持久性(durability)，简称ACID，正是这四个特性保证了事务的安全性。

**原子性**： 一个事务必须被视为一个不可分割的最小工作单元，整个事务中的所有操作要么全部提交成功，要么全部失败回滚。

**一致性**：数据库总是从一个一致性的状态转换到另外一个一致性的状态。

**隔离性**：隔离性表示一个事务所做的修改在最终提交以前，对其他事务是否可见。数据库有四种隔离级别，不同的隔离级别，一个事务对其他事务的可见性是不同的。下面我们会详细讲解这四种隔离级别。

**持久性**：一旦事务提交，其所做的修改就会永久保存到数据库中。

## 脏读、不可重复读、幻读

### 脏读

脏读是指读取到了没有提交的数据。

比如张三的账户中有500元，然后同时开启两个事务：事务A和事务B，
事务B将张三账户的余额改为1000元，但是事务B没有提交；然后事务A读取张三账户的余额，如果读取的结果为1000元，就属于脏读。因为这个结果很可能被rollback，如果基于1000元去做业务操作（比如给李四转1000元）的话很有可能出现严重的错误。

### 不可重复读

不可重复读是指某一条或某几条记录的内容在多次查询的结果中不一致。

比如张三的账户中有500元，然后同时开启两个事务：事务A和事务B，事务A先查询张三的账户余额，结果为500元；然后事务B将张三的账户余额修改为1000元，然后事务B提交；事务A再次查询张三的账户余额，结果为1000元，这种情况就称之为不可重复读。

### 幻读

幻读是指多次查询同一范围内的数据，后一次查询到前一次不包含的数据行。

比如数据库中有两条记录：张三500元、李四1000元，然后同时开启两个事务：事务A和事务B，事务A查询余额大于600元的记录，得到一条结果；然后事务B插入一条记录：王五800元，事务B提交；事务A再次查询余额大于600元的记录，如果得到2条结果，就称之为幻读。

### 不可重复读和幻读的区别

不可重复读和幻读很容易搞混，这两者有些相似，我们可以用一个简单的方法来区分，不可重复读的原因在于update和delete，而幻读的原因在于insert。



## 隔离级别

为什么要在事务隔离级别前先介绍脏读、不可重复读和幻读，这是因为四种隔离级别对于它们的忍受程度是不一样的。

### 未提交读（Read Uncommitted）

事务中的修改，即使没有提交，对其他事务也是可见的。在这个级别中可能出现脏读、不可重复读和幻读。

这种级别一般数据库都不会使用。

### 提交读（Read Committed, RC）

在这个级别中事务中的修改只有在本事务中可见，提交后才对其他事务可见。在这个级别中解决了脏读的问题，但是还是会出现不可重复读和幻读，因此这个级别有时也叫做不可重复读。

RC是大多数数据的默认隔离级别，但是MySQL的默认级别并不是RC。

### 可重复读（Repeatable Read, RR）

可重复读要求不能出现脏读和不可重复读的情况，但是允许出现幻读。

RR是MySQL默认的隔离级别，虽然RR允许出现幻读，但是MySQL的InnoDB存储引擎通过MVCC（多版本并发控制）解决了幻读的问题。

### 可串行化（Serializable）

可串行化是最高的隔离级别，它强制事务串行执行，因此同时解决了脏读、不可重复读和幻读。

实际应用中很少使用可串行化，除非非常需要确保数据的一致性，并且可以接受低效率的情况下，才考虑采用此级别。


下面我们用一张表格来总结下这四种隔离级别：

隔离级别 | 脏读 | 不可重复读 | 幻读
---|---|---|---
未提交读 | 可能 | 可能 | 可能 
提交读 | 不可能 | 可能 | 可能 
可重复读 | 不可能 | 不可能 | 可能 
可串行化 | 不可能 | 不可能 | 不可能 

## 隔离级别的实现

数据库对于隔离级别的实现就是使用并发控制机制对在同一时间执行的事务进行控制，限制不同的事务对于同一资源的访问和更新。

### 锁

锁是一种最为常见的并发控制机制，在一个事务中，我们并不会将整个数据库都加锁，而是只会锁住那些需要访问的数据项， MySQL 和常见数据库中的锁都分为两种，共享锁（Shared）和互斥锁（Exclusive），前者也叫读锁，后者叫写锁。读锁保证了读操作可以并发执行，相互不会影响，而写锁保证了在更新数据库数据时不会有其他的事务访问或者更改同一条记录造成不可预知的问题。

按照锁的粒度来区分的话，锁可以分为表锁、行锁。表锁是MySQL最基本的锁，并且是开销最小的锁，但是由于它会锁住整张表，所以并发效率比较低。而行锁只锁住需要的行，可以最大程度地支持并发处理，但是同时行锁的开销也是最大的。

四种隔离级别中，未提交读任何操作都不会加锁，也没有使用其他的并发控制机制，所以会出现脏读的情况；剩下的三种隔离级别都会使用到锁，其中可串行化会在读取的每一行都加锁，因此可能会导致大量的超时和锁竞争的问题。

### 多版本并发控制

虽然锁可以实现并发控制，但是在实际环境中数据库的事务大都是只读的，读请求是写请求的很多倍，如果写请求和读请求之前没有并发控制机制，那么最坏的情况也是读请求读到了已经写入的数据，这对很多应用完全是可以接受的。在这种大前提下，数据库系统引入了另一种并发控制机制 - 多版本并发控制（Multiversion Concurrency Control，MVCC）。

MVCC并没有统一的实现标准，因此不同数据库或者同一个数据的不同存储引擎之间的实现都不尽相同，下面我们简单介绍下InnoDB的实现方式。InnoDB是通过在每行记录的后面保存2个隐藏列来实现的，这两个列一个保存了行的创建版本号，一个保存了行的过期版本号。每开启一个新的事务，系统版本号都会自动递增，事务开启时刻的系统版本号会作为事务的版本号，用来和查询到的每行记录的版本号进行比较，下面我们看下在RR级别下，MVCC是如何操作的：

- **SELECT**  读取数据符合条件的数据，如果数据存在回滚日志（即其他事务修改的数据还未提交），则使用回滚日志数据替换读取的数据，最后根据以下两个条件进行检查:
  - 创建版本号<=当前事务版本号，保证事务读取的行，要么是事务开始前就已经存在，或者是事务自身插入或修改过的。
  - 删除版本号未定义或者>当前事务版本号，保证事务开始前未被删除。
- **INSERT**  保存当前事务版本号为行的创建版本号。
- **DELETE**  保存当前事务版本号为行的删除版本号。
- **UPDATE**  插入一条新纪录，保存当前事务版本号为行创建版本号，同时保存当前事务版本号到原来删除的行。

MVCC使得大多数读操作都不需要加锁，这样设计使得读数据操作简单，性能很好，并且也能保证只会读取到符合标准的行。不足之处是需要额外的存储空间，需要更多的行检查工作，以及一些额外的维护工作。另外MVCC只在RC和RR级别下工作，其他两个级别与MVCC不兼容。



