---
title: Redis持久化
categories:
  - Redis
tags:
  - Redis
date: 2019-03-10 08:26:07
---

Redis 支持 RDB 和 AOF 两种持久化机制，持久化功能有效避免因进程退出造成的数据丢失问题，当下次重启时利用之前持久化的文件即可实现数据恢复。<!-- more -->

> 本篇文章基于 Redis 3.2

## RDB

RDB 持久化是把当前进程数据生成快照保存到硬盘的过程，触发 RDB 持久化过程分为手动触发和自动触发。

### 触发机制

#### 手动触发

手动触发就是手动执行 bgsave 命令，Redis 进程执行 fork 操作创建子进程，RDB 持久化过程由子进程负责，完成后自动结束，阻塞只发生在 fork 阶段，一般时间很短。

#### 自动触发

- 使用 save 相关配置，如```save m n```，表示 m 秒内数据修改 n 次时，自动触发 bgsave。
- 如果从节点执行全量复制操作，主节点自动执行 bgsave 生成 RDB 文件并发送给从节点。
- 执行 debug reload 命令重新加载 Redis 时，也会自动触发 bgsave 操作。
- 默认情况下执行 shutdown 命令时，如果没有开启 AOF 持久化功能则自动执行 bgsave。

### 流程说明

#### fork

Redis 在持久化时会调用 glibc 的函数fork产生一个子进程，快照持久化完全交给子进程来处理，父进程继续处理客户端请求。子进程刚刚产生时，它和父进程共享内存里面的代码段和数据段。

#### COW（Copy On Write）
子进程做数据持久化，它不会修改现有的内存数据结构，它只是对数据结构进行遍历读取，然后序列化写到磁盘中。但是父进程不一样，它必须持续服务客户端请求，然后对内存数据结构进行不间断的修改。

这个时候就会使用操作系统的 COW 机制来进行数据段页面的分离。数据段是由很多操作系统的页面组合而成，当父进程对其中一个页面的数据进行修改时，会将被共享的页面复制一份分离出来，然后对这个复制的页面进行修改。这时子进程相应的页面是没有变化的，还是进程产生时那一瞬间的数据。

### 优缺点

#### 优点

- RDB 是一个紧凑压缩的二进制文件，非常适合备份、全量复制等场景。
- Redis 加载 RDB 恢复数据远远快于 AOF 的方式。

#### 缺点

- 没办法实时持久化。
- RDB 文件二进制格式存在多个版本，老版本 Redis 服务无法兼容新版本 RDB 文件。 


## AOF (append only file)

AOF 持久化以独立日志的方式记录每次写命令，重启时再次执行 AOF 文件中的命令达到恢复数据的目的。

AOF 主要作用是解决数据持久化的实时性，目前已经是 Redis 持久化的主流方式。

### 开启 AOF

开启 AOF 功能需要设置配置 ```appendonly yes```，默认不开启。AOF 文件名通过 appendfilename 配置设置，默认文件名是 appendonly.aof。

### AOF 流程

AOF 流程大致分为以下四步：

1. 所有写入命令会追加到 aof_buf (缓冲区) 中
2. AOF 缓冲区根据对应的策略向硬盘做同步操作
3. 随着 AOF 文件越来越大，需要定期对 AOF 文件重写，达到压缩的目的
4. 当 Redis 服务重启时，加载 AOF 文件进行数据恢复。 

#### 写缓冲区

Redis 把命令写到缓冲区而不是直接写到 AOF 文件的原因主要有两点：一是先写缓冲区可以提高性能，二是 Redis 可以提供多种缓冲区同步硬盘策略，在性能和安全性方面做出平衡。

#### 文件同步

Redis 提供了三种策略用于缓冲区想硬盘同步：

- always : 命令写入缓冲区后，调用系统 fsync 操作，强制同步 AOF 文件。这种策略虽然保证了安全性，但是会严重影响 Redis 性能，不建议配置。

- no : 命令写入缓冲区后，调用系统 write 操作，由系统决定什么时候写入到 AOF 文件。这种配置同步到 AOF 文件周期不可控，而且会加大每次同步硬盘的数据量，虽然提高了性能，但在安全性无法保证。

- everysec : 命令写入缓冲区后，调用系统 write 操作，由专门线程每秒调用一次 fsync 命令。这种配置兼顾性能与安全性，是建议的同步策略，也是默认配置。

#### 重写机制

随着命令不断写入，AOF 文件的体积越来越大，为了解决这个问题，Redis 引入了重写机制。

其原理就是开辟一个子进程对内存进行遍历转换成一系列 Redis 的操作指令，序列化到一个新的 AOF 日志文件中。序列化完毕后再将操作期间发生的增量 AOF 日志追加到这个新的 AOF 日志文件中，追加完毕后就立即替代旧的 AOF 日志文件了，瘦身工作就完成了。

重写能够缩小文件体积的原因有三个：

- 已经超时的数据不用再写入文件
- 去除无效命令
- 多条命令合并成一条

AOF 重写可以分为手动触发和自动触发：

- 手动触发 ： 直接调用 bgrewriteaof 命令
- 自动触发 ： 根据 auto-aof-rewrite-min-size 和 auto-aof-rewrite-percentage 参数决定自动触发时机。
  - auto-aof-rewrite-min-size ： 表示 AOF 文件重写时文件的最小体积，默认是 64M。
  - auto-aof-rewrite-percentage ： 表示 AOF 文件当前大小（aof-current-size）和上次重写完成后的文件大小（aof-base-size）的比值。
  - 自动触发时机 = aof-current-size > auto-aof-rewrite-min-size && (aof-current-size - aof-base-size) / aof-base-size >= auto-aof-rewrite-percentage

  
## Redis 4.0 混合持久化

重启 Redis 时，我们很少使用 rdb 来恢复内存状态，因为会丢失大量数据。我们通常使用 AOF 日志重放，但是重放 AOF 日志性能相对 rdb 来说要慢很多，这样在 Redis 实例很大的情况下，启动需要花费很长的时间。

Redis 4.0 为了解决这个问题，带来了一个新的持久化选项——混合持久化。将 rdb 文件的内容和增量的 AOF 日志文件存在一起。这里的 AOF 日志不再是全量的日志，而是自持久化开始到持久化结束的这段时间发生的增量 AOF 日志，通常这部分 AOF 日志很小。

于是在 Redis 重启的时候，可以先加载 rdb 的内容，然后再重放增量 AOF 日志就可以完全替代之前的 AOF 全量文件重放，重启效率因此大幅得到提升。

## 参考文档

- 《Redis开发与运维》
- 《Redis深度历险》




