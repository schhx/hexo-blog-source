---
title: 并发编程简介
categories:
  - Java并发编程
tags:
  - Java并发编程
date: 2018-06-18 21:08:22
---

作为一个Java程序员，你肯定或多或少地接触了并发编程，<!-- more -->比如开发的Web服务可以并发地处理多个请求，程序并发地请求数据库等等。本篇文章我们就来简单介绍下并发编程。


## 基本概念

### 线程与进程
进程和线程都是一个时间段的描述，是CPU工作时间段的描述。

进程是个比较粗粒度的概念，CPU在进程之间切换需要载入进程的上下文、执行进程、保存进程的上下文，所以进程的上下文切换很耗性能，为了进一步提高CPU的利用率，出现了线程。

一个进程可以包含多个线程，线程相对于进程粒度更小，尽管线程切换也需要载入和保存线程的上下文，但是线程共用进程的上下文，所以线程的切换相比较于进程要快的多。

形象点说，我们启动的一个Java程序就是一个进程，Java程序里又包含了很多线程。

### 并发与并行
并发与并行都表示同时执行多件事情，但是它们又不一样。并发是指逻辑上是同时执行，但实际上可能并不是，并行是真正的同时执行。

这么说还很难理解，我们可以举个形象点的例子。比如你需要烧水和洗菜，如果顺序地做的话可能是这样的，你把水加到水壶来开始烧，你等5分钟后水烧开了，然后把水倒到保温杯里，最后再去洗菜。但是这么做效率太低，你可以在等烧水的空闲时间去洗菜，等水烧开后再去倒水，这样效率就比较高了。这种情况就是并发，看起来你同时做了两件事情，但其实同一时刻你只做了一件事。

那怎么样才算并行呢？如果现在有两个人，一个人烧水，另一个人洗菜，那同一时刻烧水和洗菜都在执行，这就是并行。

如果类比一下我们就会发现，一个人就相当于一个CPU核，一个任务就相当于一个线程。单核CPU同一时刻只能运行一个线程，而多核CPU可以并行运行多个线程。单核CPU支持并发，但不支持并行，多核CPU可以同时支持并发与并行。

## 什么是并发编程
并发编程是指编写一个含有多个线程的程序或者编写一个可以被多个线程同时执行的程序。

## 并发编程的优势

### 发挥多核处理器的能力
现代CPU一般都有多个核心，如果我们的程序只有一个线程的话，则只会有一个CPU核在工作，其他CPU核处于空闲状态，这完全是浪费多核CPU的计算能力。

另外一方面，由于CPU的处理能力极快，而外围设备(比如I/O)处理能力较慢，单线程会使得CPU在等待外围设备的处理结果时处于空闲状态，这也极大地浪费了CPU的计算能力。

所以说，合理地使用多线程可以充分发挥发挥多核处理器的能力。

### 建模的简单性
如果你的程序需要处理一个复杂的任务，不妨把这个复杂的任务拆分成几个简单的任务，而让每个线程处理一个任务，并在合适的地方进行同步，这将大大简化程序的复杂性，同时每个简单的任务出错的可能性更低，更容易测试。

一个形象点的例子是生产汽车的流水线，如果让一个人从头到尾开始生产一辆汽车将会复杂无比，而且汽车被正确制造出来的概率也比较低。如果把整个过程拆分成几千个流程，每个流程都足够简单，每个人只需完成一个简单的流程，就能将汽车完整地制造出来。


## 并发编程的挑战

### 安全性问题

编写正确的程序很难，编写正确的并发程序更难。一个程序在单线程环境下可以正确的工作，但很可能在多线程环境下得出错误的结果，而且多线程下的错误原因更加隐蔽。比如```UnsafeSequence```类在单线程环境下调用```getNext```方法5000次，最后value的值会是5000，但是多线程并发调用最后的结果很可能不是5000，而是小于5000的某个值，如果学习过JMM我们就会知道这是由于value值在多个线程间没有正确同步引起的。

```
public class UnsafeSequence {
    private int value;
    
    public int getNext() {
        return value++;
    }
}

```

解决这个问题，我们可以使用同步代码块或者线程安全的AtomicInteger类。

### 活跃性问题

不正确的并发程序除了会得出错误的结果外，还有可能引起活跃性问题，活跃性问题是指某种操作因为某种原因再也无法执行下去。活跃性性问题是一个非常严重的问题，因为通常发生活跃性问题时，除了重启应用外没有其他有效的方法让程序恢复过来。它通常有以下几种表现形式

#### 死锁

如果A线程在等待B线程持有的锁，而B线程也在等待A线程持有的锁，他们之间就会相互等待而再也不会执行下去，这就是死锁，关于死锁的经典例子之一就是哲学家就餐问题。

#### 活锁

和死锁不一样活锁并不会阻塞线程，但是会使线程不断重复相同的操作，使得线程不能再做进一步的操作。比如，你和朋友约在麦当劳见面，但是附近有两家，你去了A麦当劳，而你朋友去了B麦当劳，然后你走向B麦当劳找你朋友，而你朋友同时走向A麦当劳去找你，你们俩到达后都没有找到然后再折返，如此反复，结果都没吃上饭。

#### 饥饿

当线程无法获得需要的资源而一直不能执行时，我们就称之为饥饿。饥饿通常发生在争夺非公平锁时，比如很多线程同时争夺一把锁，有些线程可能由于优先级比较低或者其他因素而一直获取不到锁时，就会一直的不到执行。

### 性能问题

可能你会说并发编程的优势之一不就是提高性能吗，怎么会又有性能问题呢？虽然切换线程比切换进程消耗的性能要小得多，但也是要消耗性能的，如果频繁切换线程带来的性能损耗超过了多线程带来的性能优势，那么使用多线程反而得不偿失。


## 参考文档
- 《Java并发编程实战》


